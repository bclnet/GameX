= Data

== Terms

To understand how data is stored, processed, and communicated within software systems, it is essential to first become familiar with the core terms and data types referenced throughout this manual. The following definitions provide a foundational vocabulary that will be used in later sections.

byte:: A single 8-bit unit of data capable of storing numeric values from 0-255.
bytes (byte array):: A sequence of multiple byte values representing raw binary data.
char (character):: A single Unicode character represented by a numeric code value.
str (string):: An ordered sequence of characters used to represent textual data.
bool (boolean):: A data type used to store a logical value of either `true` or `false`.
int (integer):: A numeric type used to store whole numbers without a fractional component.
float (floating point):: A numeric type used to store approximate decimal values using floating-point precision.
decimal:: A high-precision numeric type used for accurate decimal arithmetic, commonly used in financial calculations.
date:: A data type representing a calendar date, typically including year, month, and day with no time component.
datetime (date and time):: A data type representing a specific moment in time, including both date and time information.
object:: A general-purpose data type capable of holding any form of data; often serves as the base type for all values in many programming languages.
array:: A fixed-size collection of items of the same type, stored in contiguous memory and accessed by index for fast retrieval.
list:: A dynamically sized collection that stores an ordered sequence of items, typically allowing duplicates.
dict (dictionary):: A collection storing key-value pairs, enabling fast lookup of values by their associated key.

== Primatives

Primitive data types are the basic, low-level types a programming language uses to store simple values. They represent the smallest units of data and are used as the foundation on which more complex data structures are built.

They are defined by several key characteristics:

Size::
Like LEGO bricks that come in fixed sizes (1, 2, 4, or 8 blocks), primitive types occupy a specific, predefined number of bytes in memory.

image:signed.webp[singed / unsigned,250,float="right"]

Sign::
Signed vs. unsigned values determine whether negative numbers are allowed.

Signed types::: reserve the most significant bit (leftmost) to indicate whether a number is positive or negative, providing a smaller positive range but supporting negative values.

Unsigned types::: use all bits to represent magnitude, resulting in a larger positive range—but no negative values. These are ideal for measurements that never go below zero (such as counts, indexes, or pixel values).

image:endian.gif[big-endian / little-endian,250,float="right"]

Endian::
Endianness defines how multi-byte values are stored in memory.

Big-endian::: stores the most significant byte (MSB) first, similar to how humans write numbers.

Little-endian::: stores the least significant byte (LSB) first, appearing reversed to us but optimized for performance on most modern CPUs (Intel x86, many ARM systems).
Big-endian is commonly used in networking (network byte order), while little-endian is dominant in modern hardware for efficient operations.

The following table provides a concise reference to commonly used primitive data types, including their general purpose and usage scope. These definitions serve as quick-look descriptions to assist developers in identifying appropriate data types for storage, computation, and system design.

[cols="1,1,1,1,6"]
|===
|Name |Code |Python |Bytes |Description

|-
|x
|no value
|-
|pad byte

|byte
|c
|bytes of length 1
|1
|An unsigned 8-bit integer ranging from 0 to 255.

|sbyte
|b
|integer
|1
|A signed 8-bit integer ranging from -128 to 127.

|byte
|B
|integer
|1
|An unsigned 8-bit integer ranging from 0 to 255.

|bool
|?
|bool
|1
|A logical value representing either `true` or `false`.

|short
|h
|integer
|2
|A signed 16-bit integer ranging from -32,768 to 32,767.

|ushort
|H
|integer
|2
|An unsigned 16-bit integer ranging from 0 to 65,535.

|int
|i
|integer
|4
|A signed 32-bit integer used for whole numbers.

|uint
|I
|integer
|4
|An unsigned 32-bit integer storing non-negative whole numbers.

|long
|q
|integer
|8
|A signed 64-bit integer used for large whole numbers.

|ulong
|Q
|integer
|8
|An unsigned 64-bit integer storing very large non-negative whole numbers.

|nint
|N
|integer
|-
|A signed native-sized integer type that matches the platform pointer size.

|hfloat
|e
|float
|2
|A half-precision floating-point number (16-bit) supporting low-precision decimals.

|float
|f
|float
|4
|A single-precision floating-point number (32-bit) used for approximate decimals.

|double
|d
|float
|8
|A double-precision floating-point number (64-bit) used for higher-accuracy decimals.

|str
|s
|bytes
|-
|A sequence of characters used to represent text data.

|bytes
|p
|bytes
|-
|A sequence of byte values representing raw binary data.

|nint
|P
|integer
|-
|A signed native-sized integer type that matches the platform pointer size.
|===

== Streams

Data can originate from many sources, but at its core, any data transfer can be represented as a sequence of bytes known as a stream.

Streams are commonly categorized into *binary streams* and *text streams*, which can be accessed and interpreted using a `BinaryReader` or `TextReader`, respectively.

A `TextReader` typically provides methods such as `ReadWord()` and `ReadLine()` for reading text-based data, while a `BinaryReader` includes methods such as `ReadBytes()` and `ReadBoolean()` for retrieving raw or typed binary data.


=== Text Reader
The *TextReader* is a component used to read character-based data from a stream, interpreting bytes as text and providing structured access to words, lines, and other string segments.

[cols="3,1,1,1,3"]
|===
|Name |Return |Bytes |Options |Description

|copyTo(destination: BytesIO, resetAfter: bool = False)
|None
|-
|-
|xxx
|===

=== Binary Reader
The *BinaryReader* is a component used to read raw binary data from a stream, interpreting bytes as typed values such as integers, booleans, and floating-point numbers.

Base::
base extension methods
[cols="3,1,1,1,3"]
|===
|Name |Return |Bytes |Options |Description

|copyTo(destination: BytesIO, resetAfter: bool = False)
|None
|-
|-
|Copies the remaining data from the current stream into the specified destination. If resetAfter is set to True, the stream position is reset to its original location after copying.
|===

Position Methods::
The following methods provide control over the current read/write position within a stream, enabling navigation, alignment, and validation of stream state.
[cols="3,1,1,1,3"]
|===
|Name |Return |Bytes |Options |Description

|length()
|int
|-
|-
|Returns the total length of the stream in bytes.

|align(align: int = 4)
|Reader
|-
|-
|Advances the stream position to the next boundary based on the specified alignment value.

|tell()
|int
|-
|-
|Returns the current byte position within the stream.

|seek(offset: int)
|Reader
|-
|-
|Moves the stream position to the specified byte offset.

|seekAndAlign(offset: int, align: int = 4)
|Reader
|-
|-
|Moves the stream position to the specified offset and then aligns it to the given boundary.

|skip(count: int)
|Reader
|-
|-
|Moves the stream forward by the specified number of bytes.

|skipAndAlign(count: int, align: int = 4)
|int
|-
|-
|Skips the specified number of bytes and then aligns the position to the given boundary.

|end(offset: int)
|Reader
|-
|-
|Moves the stream position to the end minus the specified offset.

|peek(action, offset: int = 0, origin: int = os.SEEK_CUR)
|object
|-
|-
|Performs an action against data at a future position without advancing the current stream position.

|atEnd(end: int = None)
|bool
|-
|-
|Returns `True` if the current position is at or beyond the end of the stream (or a specified end boundary).

|ensureAtEnd(end: int = -1)
|None
|-
|-
|Validates that the stream is positioned at its expected end; raises an error or warning if not.
|===

Bytes Methods::
The following methods provide structured access to raw byte data from a stream.
[cols="3,1,1,1,3"]
|===
|Name |Return |Bytes |Options |Description

|read(data: bytes, offset: int, size: int)
|bytes
|:size
|-
|Reads a specified number of bytes from the stream into the supplied buffer beginning at the given offset.

|readBytes(size: int)
|bytes
|:size
|-
|Reads and returns a new byte array containing the specified number of bytes.

|readL8Bytes(maxLength: int = 0, endian: bool = False)
|bytes
|1+read
|:endian
|Reads a length-prefixed (8-bit) byte sequence; if `maxLength` is provided, reading stops at the maximum length.
       
|readL16Bytes(self, maxLength: int = 0, endian: bool = False)
|bytes
|2+read
|:endian
|Reads a length-prefixed (16-bit) byte sequence, optionally honoring specified endianness and maximum length.

|readL32Bytes(maxLength: int = 0, endian: bool = False)
|bytes
|4+read
|:endian
|Reads a length-prefixed (32-bit) byte sequence, with support for endianness and length limiting.

|readToEnd()
|bytes
|-
|-
|Reads all remaining bytes in the stream and returns them as a byte sequence.

|readToValue(value: int = b'\x00', length: int = 65535, ms: BytesIO = None)
|bytes
|-
|-
|Reads bytes sequentially until the specified terminator value is encountered, a length limit is reached, optionally uses the provided `BytesIO` object as buffer.
|===

Primitives Methods::
The following methods read primitive typed values from the stream, converting raw bytes into strongly typed numeric or logical values.
[cols="3,1,1,1,3"]
|===
|Name |Return |Bytes |Options |Description

|readBoolean()
|bool
|1
|-
|Reads a single byte and returns a Boolean value (`true` or `false`).

|readDouble()
|float
|8
|little
|Reads 8 bytes and returns a 64-bit floating-point number.

|readSByte()
|int
|1
|signed, little
|Reads 1 byte and returns a signed 8-bit integer.

|readInt16()
|int
|2
|signed, little
|Reads 2 bytes and returns a signed 16-bit integer.

|readInt32()
|int
|4
|signed, little
|Reads 4 bytes and returns a signed 32-bit integer.

|readInt64()
|int
|8
|signed, little
|Reads 8 bytes and returns a signed 64-bit integer.

|readSingle()
|float
|4
|little
|Reads 4 bytes and returns a 32-bit floating-point number.

|readByte()
|int
|1
|-
|Reads 1 byte and returns an unsigned 8-bit integer.

|readUInt16()
|int
|2
|unsigned, little
|Reads 2 bytes and returns an unsigned 16-bit integer.

|readUInt32()
|int
|4
|unsigned, little
|Reads 4 bytes and returns an unsigned 32-bit integer.

|readUInt64()
|int
|8
|signed, little
|Reads 8 bytes and returns an unsigned 64-bit integer.

|readDecimal()
|Decimal
|8
|little
|Reads a fixed-format 128-bit decimal and returns a precise decimal numeric value.

5+| *primatives : endian*

|readDoubleE()
|float
|8
|big
|Reads 8 bytes and returns a 64-bit floating-point number.

|readInt16E()
|int
|2
|signed, big
|Reads 2 bytes and returns a signed 16-bit integer.

|readInt32E()
|int
|4
|signed, big
|Reads 4 bytes and returns a signed 32-bit integer.

|readInt64E()
|int
|8
|signed, big
|Reads 8 bytes and returns a signed 64-bit integer.

|readSingleE()
|float
|4
|big
|Reads 4 bytes and returns a 32-bit floating-point number.

|readUInt16E()
|int
|2
|unsigned, big
|Reads 2 bytes and returns an unsigned 16-bit integer.

|readUInt32E()
|int
|4
|unsigned, big
|Reads 4 bytes and returns an unsigned 32-bit integer.

|readUInt64E()
|int
|8
|unsigned, big
|Reads 8 bytes and returns an unsigned 64-bit integer.

|readDecimalE()
|Decimal
|8
|big
|Reads a fixed-format 128-bit decimal and returns a precise decimal numeric value.

5+| *primatives : endianX*

|readDoubleX(endian: bool)
|float
|8
|:endian
|Reads 8 bytes and returns a 64-bit floating-point number.

|readInt16X(endian: bool)
|int
|2
|signed, :endian
|Reads 2 bytes and returns a signed 16-bit integer.

|readInt32X(endian: bool)
|int
|4
|signed, :endian
|Reads 4 bytes and returns a signed 32-bit integer.

|readInt64X(endian: bool)
|int
|8
|signed, :endian
|Reads 8 bytes and returns a signed 64-bit integer.

|readSingleX(endian: bool)
|float
|4
|signed, :endian
|Reads 4 bytes and returns a 32-bit floating-point number.

|readUInt16X(endian: bool)
|int
|2
|unsigned, :endian
|Reads 2 bytes and returns an unsigned 16-bit integer.

|readUInt32X(endian: bool)
|int
|4
|unsigned, :endian
|Reads 4 bytes and returns an unsigned 32-bit integer.

|readUInt64X(endian: bool)
|int
|8
|unsigned, :endian
|Reads 8 bytes and returns an unsigned 64-bit integer.

|readDecimalX(endian: bool)
|Decimal
|8
|:endian
|Reads a fixed-format 128-bit decimal and returns a precise decimal numeric value.

5+| *primatives : specialized*

|readIntV7()
|int
|variable
|little
|xxx

|readIntV7X(endian: bool)
|int
|variable
|:endian
|xxx

|readIntV8()
|int
|variable
|little
|xxx

|readIntV8X(endian: bool)
|int
|variable
|little
|xxx

|readBool32(self)
|bool
|4
|little
|xxx

|readGuid(self)
|bytes
|16
|-
|xxx
|===

Strings Methods::
The following methods provide structured access to character and string values, supporting fixed-width, variable-width, and length-prefixed encodings.

[cols="3,1,1,1,3"]
|===
|Name |Return |Bytes |Options |Description

5+|*General String and Character Reading*

|readChar()
|chr
|variable
|-
|Reads a single character from the stream.

|readChars(count: int)
|list[chr]
|:count
|-
|Reads the specified number of characters and returns them as a sequence.

|readString()
|str
|-
|-
|Reads a string from the stream using the default encoding.

|readLine()
|str
|-
|-
|Reads characters until a newline sequence is encountered and returns the resulting text.

5+|*OEM-Encoded (Legacy Codepage) Strings*

|readL16OString(codepage: int = 1252)
|str
|variable
|-
|Reads a 16-bit length-prefixed string using the specified OEM codepage (default 1252).

5+|*Wide (Unicode-style) Strings — Fixed and Variable Length*

|readFWString(length: int)
|str
|length
|-
|Reads a fixed-width wide string of the specified character length.

|readVWString(length: int = 65535, stopValue: int = b'\x00', ms: BytesIO = None)
|str
|variable
|-
|Reads a variable-width wide string, stopping at a terminator or maximum length, optionally writing to a buffer.

|readL8WString(maxLength: int = 0, endian: bool = False)
|str
|1+variable
|:endian
|Reads an 8-bit length-prefixed wide string.

|readL16WString(maxLength: int = 0, endian: bool = False)
|str
|2+variable
|:endian
|Reads a 16-bit length-prefixed wide string.

|readL32WString(maxLength: int = 0, endian: bool = False)
|str
|4+variable
|:endian
|Reads a 32-bit length-prefixed wide string.

// |readLV8WString(maxLength: int = 0, endian: bool = False)
// |str
// |-
// |-
// |xxx

5+|*UTF-Style Unicode Strings (U-Series)*

|readFUString(length: int)
|str
|length
|-
|Reads a fixed-length UTF-encoded string.

|readVUString(length: int = 65535, stopValue: int = b'\x00', ms: BytesIO = None)
|str
|variable
|-
|Reads a variable-length UTF-encoded string, stopping when terminator or length limit is reached.

|readL8UString(maxLength: int = 0, endian: bool = False)
|str
|1+variable
|:endian
|Reads an 8-bit length-prefixed UTF-encoded string.

|readL16UString(maxLength: int = 0, endian: bool = False)
|str
|2+variable
|:endian
|Reads a 16-bit length-prefixed UTF-encoded string.

|readL32UString(maxLength: int = 0, endian: bool = False)
|str
|4+variable
|:endian
|Reads a 32-bit length-prefixed UTF-encoded string.

// |readLV8UString(maxLength: int = 0, endian: bool = False)
// |str
// |-
// |-
// |xxx

5+|*ASCII Strings (A-Series)*

|readFAString(length: int)
|str
|length
|-
|Reads a fixed-length ASCII string.

|readVAString(length: int = 65535, stopValue: int = b'\x00', ms: BytesIO = None)
|str
|-
|-
|Reads a variable-length ASCII string, stopping on terminator or when maximum length is reached.

|readL8AString(maxLength: int = 0, endian: bool = False)
|str
|1+variable
|:endian
|Reads an 8-bit length-prefixed ASCII string.

|readL16AString(maxLength: int = 0, endian: bool = False)
|str
|2+variable
|:endian
|Reads a 16-bit length-prefixed ASCII string.

|readL32AString(maxLength: int = 0, endian: bool = False)
|str
|4+variable
|:endian
|Reads a 32-bit length-prefixed ASCII string.

// |readLV8AString(maxLength: int = 0, endian: bool = False)
// |str
// |-
// |-
// |xxx

5+|*Extended-Encoding Strings (X-Series)*

|readFXString(encoding: str, length: int)
|str
|length^
|-
|Reads a fixed-length string using a specified encoding.

|readVXString(encoding: str, length: int = 65535, stopValue: int = b'\x00', ms: BytesIO = None)
|str
|variable
|-
|Reads a variable-length string using the 

|readL8XString(encoding: str, maxLength: int = 0, endian: bool = False)
|str
|1+variable
|:endian
|Reads an 8-bit length-prefixed string with custom encoding.specified encoding

|readL16XString(encoding: str, maxLength: int = 0, endian: bool = False)
|str
|2+variable
|:endian
|Reads a 16-bit length-prefixed string with custom encoding.

|readL32XString(encoding: str, maxLength: int = 0, endian: bool = False)
|str
|4+variable
|:endian
|Reads a 16-bit length-prefixed string with custom encoding.

// |readLV8XString(encoding: str, maxLength: int = 0, endian: bool = False)
// |str
// |-
// |-
// |xxx

|===

=== Structs
methods for reading structs

[cols="3,1,1,1,3"]
|===
|Name |Return |Bytes |Options |Description

5+| *struct : single*

|readF(factory: callable)
|object
|cls
|-
|xxx

|readP(cls: callable, pat: str)
|object
|cls
|-
|xxx

|readS(cls: object, sizeOf: int = -1)
|object
|cls
|-
|xxx

|===

=== Structs : Array
methods for reading structs

[cols="3,1,1,1,3"]
|===
|Name |Return |Bytes |Options |Description


5+| *struct : array - factory*

|readL8FArray(factory: callable, endian: bool = False, obj: list[object] = None)
|list[object]
|cls
|-
|xxx

|readL16FArray(factory: callable, endian: bool = False, obj: list[object] = None)
|list[object]
|cls
|-
|xxx

|readL32FArray(factory: callable, endian: bool = False, obj: list[object] = None)
|list[object]
|cls
|-
|xxx

|readLV7FArray(factory: callable, endian: bool = False, obj: list[object] = None)
|list[object]
|cls
|-
|xxx

|readLV8FArray(factory: callable, endian: bool = False, obj: list[object] = None)
|list[object]
|cls
|-
|xxx

|readFArray(factory: callable, count: int, obj: list[object] = None)
|list[object]
|cls
|-
|xxx

|readFIArray(factory: callable, count: int, obj: list[object] = None)
|list[object]
|cls
|-
|xxx

5+| *struct : array - pattern / primative*

|readL8PArray(cls: callable, pat: str, obj: list[object] = None)
|list[object]
|cls
|-
|xxx

|readL16PArray(cls: callable, pat: str, endian: bool = False, obj: list[object] = None)
|list[object]
|cls
|-
|xxx

|readL32PArray(cls: callable, pat: str, endian: bool = False, obj: list[object] = None)
|list[object]
|cls
|-
|xxx

|readLV7PArray(cls: callable, pat: str, endian: bool = False, obj: list[object] = None)
|list[object]
|cls
|-
|xxx

|readLV8PArray(cls: callable, pat: str, endian: bool = False, obj: list[object] = None)
|list[object]
|cls
|-
|xxx

|readPArray(cls: callable, pat: str, count: int, obj: list[object] = None)
|list[object]
|cls
|-
|xxx

5+| *struct : array - struct*

|readL8SArray(cls: object, sizeOf: int = 0, obj: list[object] = None)
|list[object]
|cls
|-
|xxx

|readL16SArray(cls: object, sizeOf: int = 0, endian: bool = False, obj: list[object] = None)
|list[object]
|cls
|-
|xxx

|readL32SArray(cls: object, sizeOf: int = 0, endian: bool = False, obj: list[object] = None)
|list[object]
|cls
|-
|xxx

|readLV7SArray(cls: object, sizeOf: int = 0, endian: bool = False, obj: list[object] = None)
|list[object]
|cls
|-
|xxx

|readLV8SArray(cls: object, sizeOf: int = 0, endian: bool = False, obj: list[object] = None)
|list[object]
|cls
|-
|xxx

|readSArray(cls: object, count: int, sizeOf: int = 0, obj: list[object] = None)
|list[object]
|cls
|-
|xxx

5+| *struct : array - each*

|readSEach(cls: object, count: int)
|list[object]
|cls
|-
|xxx

|readTEach(cls: object, sizeOf: int, count: int)
|list[object]
|cls
|-
|xxx

|===

=== Structs : List
methods for reading structs

[cols="3,1,1,1,3"]
|===
|Name |Return |Bytes |Options |Description

5+| *struct : list - factory*
|readL8FList(actory: callable, obj: object = None)
|list[object]
|cls
|-
|xxx

|readL16FList(factory: callable, endian: bool = False, obj: object = None)
    |list[object]
|cls
|-
|xxx

|readL32FList(factory: callable, endian: bool = False, obj: object = None)
|list[object]
|cls
|-
|xxx

|readLV7FList(factory: callable, endian: bool = False, obj: object = None)
|list[object]
|cls
|-
|xxx

|readLV8FList(factory: callable, endian: bool = False, obj: object = None)
|list[object]
|cls
|-
|xxx

|readFList(factory: callable, count: int, obj: object = None)
|list[object]
|cls
|-
|xxx

|readFIList(factory: callable, count: int, obj: object = None)
|list[object]
|cls
|-
|xxx

5+| *struct : list - pattern*

|readL8PList(cls: callable, pat: str, obj: list[object] = None)
|list[object]
|cls
|-
|xxx

|readL16PList(cls: callable, pat: str, endian: bool = False, obj: list[object] = None)
|list[object]
|cls
|-
|xxx

|readL32PList(cls: callable, pat: str, endian: bool = False, obj: list[object] = None)
|list[object]
|cls
|-
|xxx

|readLV7PList(cls: callable, pat: str, endian: bool = False, obj: list[object] = None)
|list[object]
|cls
|-
|xxx

|readLV8PList(cls: callable, pat: str, endian: bool = False, obj: list[object] = None)
|list[object]
|cls
|-
|xxx

|readPList(cls: callable, pat: str, count: int, obj: list[object] = None) 
|list[object]
|cls
|-
|xxx

5+| *struct : list - struct*

|readL8SList(cls: object, sizeOf: int = 0, obj: list[object] = None)|list[object]
|cls
|-
|xxx

|readL16SList(cls: object, sizeOf: int = 0, endian: bool = False, obj: list[object] = None)
|list[object]
|cls
|-
|xxx

|readL32SList(cls: object, sizeOf: int = 0, endian: bool = False, obj: list[object] = None)
|list[object]
|cls
|-
|xxx

|readLV7SList(cls: object, sizeOf: int = 0, endian: bool = False, obj: list[object] = None)
|list[object]
|cls
|-
|xxx

|readLV8SList(cls: object, sizeOf: int = 0, endian: bool = False, obj: list[object] = None)
|list[object]
|cls
|-
|xxx

|readSList(cls: object, count: int, sizeOf: int = 0, obj: list[object] = None)
|list[object]
|cls
|-
|xxx

|===

=== Structs : Many
methods for reading structs

[cols="3,1,1,1,3"]
|===
|Name |Return |Bytes |Options |Description


5+| *struct : many - factory*

|readL8FMany(clsKey: object, keyFactory: callable, valueFactory: callable, endian: bool = False, obj: object = None)
|dict[object, object]
|-
|-
|xxx

|readL16FMany(clsKey: object, keyFactory: callable, valueFactory: callable, endian: bool = False, obj: object = None)
|dict[object, object]
|-
|-
|xxx

|readL32FMany(clsKey: object, keyFactory: callable, valueFactory: callable, endian: bool = False, obj: object = None)
|dict[object, object]
|-
|-
|xxx

|readC32FMany(clsKey: object, keyFactory: callable, valueFactory: callable, endian: bool = False, obj: object = None)
|dict[object, object]
|-
|-
|xxx

|readFMany(clsKey: object, keyFactory: callable, valueFactory: callable, count: int, obj: object = None)
|dict[object, object]
|-
|-
|xxx

5+| *struct : many - pattern*

|readL8PMany(clsKey: object, pat: str, valueFactory: callable, endian: bool = False, obj: dict[object, object] = None)
|dict[object, object]
|-
|-
|xxx

|readL16PMany(clsKey: object, pat: str, valueFactory: callable, endian: bool = False, obj: dict[object, object] = None)
|dict[object, object]
|-
|-
|xxx

|readL32PMany(clsKey: object, pat: str, valueFactory: callable, endian: bool = False, obj: dict[object, object] = None)
|dict[object, object]
|-
|-
|xxx

|readC32PMany(clsKey: object, pat: str, valueFactory: callable, endian: bool = False, obj: dict[object, object] = None)
|dict[object, object]
|-
|-
|xxx

|readPMany(clsKey: object, pat: str, valueFactory: callable, count: int, obj: dict[object, object] = None)
|dict[object, object]
|-
|-
|xxx

5+| *struct : many - struct*

|readL8SMany(clsKey: object, valueFactory: callable, endian: bool = False, obj: dict[object, object] = None)
|dict[object, object]
|-
|-
|xxx

|readL16SMany(clsKey: object, valueFactory: callable, endian: bool = False, obj: dict[object, object] = None)
|dict[object, object]
|-
|-
|xxx

|readL32SMany(clsKey: object, valueFactory: callable, endian: bool = False, obj: dict[object, object] = None)
|dict[object, object]
|-
|-
|xxx

|readC32SMany(clsKey: object, valueFactory: callable, endian: bool = False, obj: dict[object, object] = None)
|dict[object, object]
|-
|-
|xxx

|readSMany(clsKey: object, valueFactory: callable, count: int, obj: dict[object, object] = None)
|dict[object, object]
|-
|-
|xxx


|===

=== Numerics
methods for reading numerics

[cols="3,1,1,1,3"]
|===
|Name |Return |Bytes |Options |Description

|readHalf()
|float
|-
|-
|xxx

|readHalf16()
|float
|-
|-
|xxx

|readVector2()
|ndarray
|-
|-
|xxx

|readHalfVector2()
|ndarray
|-
|-
|xxx

|readVector3()
|ndarray
|-
|-
|xxx

|readHalfVector3()
|ndarray
|-
|-
|xxx

|readHalf16Vector3()
|ndarray
|-
|-
|xxx

|readVector4()
|ndarray
|-
|-
|xxx

|readHalfVector4()
|ndarray
|-
|-
|xxx

|readMatrix2x2()
|ndarray
|-
|-
|xxx

|readMatrix3x3()
|ndarray
|-
|-
|xxx

|readMatrix3x4()
|ndarray
|-
|-
|xxx

|readMatrix3x3As4x4()
|ndarray
|-
|-
|xxx

|readMatrix4x4()
|ndarray
|-
|-
|xxx

|readQuaternion()
|quaternion
|-
|-
|xxx

|readQuaternionWFirst()
|quaternion
|-
|-
|xxx

|readHalfQuaternion()
|quaternion
|-
|-
|xxx

|===