= Data

== Terms

To understand how data is stored, processed, and communicated within software systems, it is essential to first become familiar with the core terms and data types referenced throughout this manual. The following definitions provide a foundational vocabulary that will be used in later sections.

byte:: A single 8-bit unit of data capable of storing numeric values from 0-255.
bytes (byte array):: A sequence of multiple byte values representing raw binary data.
char (character):: A single Unicode character represented by a numeric code value.
str (string):: An ordered sequence of characters used to represent textual data.
bool (boolean):: A data type used to store a logical value of either `true` or `false`.
int (integer):: A numeric type used to store whole numbers without a fractional component.
float (floating point):: A numeric type used to store approximate decimal values using floating-point precision.
decimal:: A high-precision numeric type used for accurate decimal arithmetic, commonly used in financial calculations.
date:: A data type representing a calendar date, typically including year, month, and day with no time component.
datetime (date and time):: A data type representing a specific moment in time, including both date and time information.
object:: A general-purpose data type capable of holding any form of data; often serves as the base type for all values in many programming languages.
array:: A fixed-size collection of items of the same type, stored in contiguous memory and accessed by index for fast retrieval.
list:: A dynamically sized collection that stores an ordered sequence of items, typically allowing duplicates.
dict (dictionary):: A collection storing key-value pairs, enabling fast lookup of values by their associated key.

== Primatives

Primitive data types are the basic, low-level types a programming language uses to store simple values. They represent the smallest units of data and are used as the foundation on which more complex data structures are built.

They are defined by several key characteristics:

Size::
Like LEGO bricks that come in fixed sizes (1, 2, 4, or 8 blocks), primitive types occupy a specific, predefined number of bytes in memory.

image:signed.webp[singed / unsigned,250,float="right"]

Sign::
Signed vs. unsigned values determine whether negative numbers are allowed.

Signed types::: reserve the most significant bit (leftmost) to indicate whether a number is positive or negative, providing a smaller positive range but supporting negative values.

Unsigned types::: use all bits to represent magnitude, resulting in a larger positive range—but no negative values. These are ideal for measurements that never go below zero (such as counts, indexes, or pixel values).

image:endian.gif[big-endian / little-endian,250,float="right"]

Endian::
Endianness defines how multi-byte values are stored in memory.

Big-endian::: stores the most significant byte (MSB) first, similar to how humans write numbers.

Little-endian::: stores the least significant byte (LSB) first, appearing reversed to us but optimized for performance on most modern CPUs (Intel x86, many ARM systems).
Big-endian is commonly used in networking (network byte order), while little-endian is dominant in modern hardware for efficient operations.

The following table provides a concise reference to commonly used primitive data types, including their general purpose and usage scope. These definitions serve as quick-look descriptions to assist developers in identifying appropriate data types for storage, computation, and system design.

[cols="1,1,1,1,6"]
|===
|Name |Code |Python |Bytes |Description

|-
|x
|no value
|-
|pad byte

|byte
|c
|bytes of length 1
|1
|An unsigned 8-bit integer ranging from 0 to 255.

|sbyte
|b
|integer
|1
|A signed 8-bit integer ranging from -128 to 127.

|byte
|B
|integer
|1
|An unsigned 8-bit integer ranging from 0 to 255.

|bool
|?
|bool
|1
|A logical value representing either `true` or `false`.

|short
|h
|integer
|2
|A signed 16-bit integer ranging from -32,768 to 32,767.

|ushort
|H
|integer
|2
|An unsigned 16-bit integer ranging from 0 to 65,535.

|int
|i
|integer
|4
|A signed 32-bit integer used for whole numbers.

|uint
|I
|integer
|4
|An unsigned 32-bit integer storing non-negative whole numbers.

|long
|q
|integer
|8
|A signed 64-bit integer used for large whole numbers.

|ulong
|Q
|integer
|8
|An unsigned 64-bit integer storing very large non-negative whole numbers.

|nint
|N
|integer
|-
|A signed native-sized integer type that matches the platform pointer size.

|hfloat
|e
|float
|2
|A half-precision floating-point number (16-bit) supporting low-precision decimals.

|float
|f
|float
|4
|A single-precision floating-point number (32-bit) used for approximate decimals.

|double
|d
|float
|8
|A double-precision floating-point number (64-bit) used for higher-accuracy decimals.

|str
|s
|bytes
|-
|A sequence of characters used to represent text data.

|bytes
|p
|bytes
|-
|A sequence of byte values representing raw binary data.

|nint
|P
|integer
|-
|A signed native-sized integer type that matches the platform pointer size.
|===

== Streams

Data can originate from many sources, but at its core, any data transfer can be represented as a sequence of bytes known as a stream.

Streams are commonly categorized into *binary streams* and *text streams*, which can be accessed and interpreted using a `BinaryReader` or `TextReader`, respectively.

A `TextReader` typically provides methods such as `ReadWord()` and `ReadLine()` for reading text-based data, while a `BinaryReader` includes methods such as `ReadBytes()` and `ReadBoolean()` for retrieving raw or typed binary data.


=== Text Reader
The *TextReader* is a component used to read character-based data from a stream, interpreting bytes as text and providing structured access to words, lines, and other string segments.

[cols="3,1,1,1,6"]
|===
|Name |Return |Bytes |Options |Description

|copyTo(destination: BytesIO, resetAfter: bool = False)
|None
|-
|-
|xxx
|===

=== Binary Reader
The *BinaryReader* is a component used to read raw binary data from a stream, interpreting bytes as typed values such as integers, booleans, and floating-point numbers.

Base::
base extension methods
[cols="3,1,1,1,6"]
|===
|Name |Return |Bytes |Options |Description

|copyTo(destination: BytesIO, resetAfter: bool = False)
|None
|-
|-
|Copies the remaining data from the current stream into the specified destination. If resetAfter is set to True, the stream position is reset to its original location after copying.
|===

Position Methods::
The following methods provide control over the current read/write position within a stream, enabling navigation, alignment, and validation of stream state.
[cols="3,1,1,1,6"]
|===
|Name |Return |Bytes |Options |Description

|length()
|int
|-
|-
|Returns the total length of the stream in bytes.

|align(align: int = 4)
|Reader
|-
|-
|Advances the stream position to the next boundary based on the specified alignment value.

|tell()
|int
|-
|-
|Returns the current byte position within the stream.

|seek(offset: int)
|Reader
|-
|-
|Moves the stream position to the specified byte offset.

|seekAndAlign(offset: int, align: int = 4)
|Reader
|-
|-
|Moves the stream position to the specified offset and then aligns it to the given boundary.

|skip(count: int)
|Reader
|-
|-
|Moves the stream forward by the specified number of bytes.

|skipAndAlign(count: int, align: int = 4)
|int
|-
|-
|Skips the specified number of bytes and then aligns the position to the given boundary.

|end(offset: int)
|Reader
|-
|-
|Moves the stream position to the end minus the specified offset.

|peek(action, offset: int = 0, origin: int = os.SEEK_CUR)
|object
|-
|-
|Performs an action against data at a future position without advancing the current stream position.

|atEnd(end: int = None)
|bool
|-
|-
|Returns `True` if the current position is at or beyond the end of the stream (or a specified end boundary).

|ensureAtEnd(end: int = -1)
|None
|-
|-
|Validates that the stream is positioned at its expected end; raises an error or warning if not.
|===

Bytes Methods::
The following methods provide structured access to raw byte data from a stream.
[cols="3,1,1,1,6"]
|===
|Name |Return |Bytes |Options |Description

|read(data: bytes, offset: int, size: int)
|bytes
|:size
|-
|Reads a specified number of bytes from the stream into the supplied buffer beginning at the given offset.

|readBytes(size: int)
|bytes
|:size
|-
|Reads and returns a new byte array containing the specified number of bytes.

|readL8Bytes(maxLength: int = 0, endian: bool = False)
|bytes
|1+read
|:endian
|Reads a length-prefixed (8-bit) byte sequence; if `maxLength` is provided, reading stops at the maximum length.
       
|readL16Bytes(self, maxLength: int = 0, endian: bool = False)
|bytes
|2+read
|:endian
|Reads a length-prefixed (16-bit) byte sequence, optionally honoring specified endianness and maximum length.

|readL32Bytes(maxLength: int = 0, endian: bool = False)
|bytes
|4+read
|:endian
|Reads a length-prefixed (32-bit) byte sequence, with support for endianness and length limiting.

|readToEnd()
|bytes
|-
|-
|Reads all remaining bytes in the stream and returns them as a byte sequence.

|readToValue(value: int = b'\x00', length: int = 65535, ms: BytesIO = None)
|bytes
|-
|-
|Reads bytes sequentially until the specified terminator value is encountered, a length limit is reached, optionally uses the provided `BytesIO` object as buffer.
|===

Primitives Methods::
The following methods read primitive typed values from the stream, converting raw bytes into strongly typed numeric or logical values.
[cols="3,1,1,1,6"]
|===
|Name |Return |Bytes |Options |Description

|readBoolean()
|bool
|1
|-
|Reads a single byte and returns a Boolean value (`true` or `false`).

|readDouble()
|float
|8
|little
|Reads 8 bytes and returns a 64-bit floating-point number.

|readSByte()
|int
|1
|signed, little
|Reads 1 byte and returns a signed 8-bit integer.

|readInt16()
|int
|2
|signed, little
|Reads 2 bytes and returns a signed 16-bit integer.

|readInt32()
|int
|4
|signed, little
|Reads 4 bytes and returns a signed 32-bit integer.

|readInt64()
|int
|8
|signed, little
|Reads 8 bytes and returns a signed 64-bit integer.

|readSingle()
|float
|4
|little
|Reads 4 bytes and returns a 32-bit floating-point number.

|readByte()
|int
|1
|-
|Reads 1 byte and returns an unsigned 8-bit integer.

|readUInt16()
|int
|2
|unsigned, little
|Reads 2 bytes and returns an unsigned 16-bit integer.

|readUInt32()
|int
|4
|unsigned, little
|Reads 4 bytes and returns an unsigned 32-bit integer.

|readUInt64()
|int
|8
|signed, little
|Reads 8 bytes and returns an unsigned 64-bit integer.

|readDecimal()
|Decimal
|8
|little
|Reads a fixed-format 128-bit decimal and returns a precise decimal numeric value.

5+| *primatives : endian*

|readDoubleE()
|float
|8
|big
|Reads 8 bytes and returns a 64-bit floating-point number.

|readInt16E()
|int
|2
|signed, big
|Reads 2 bytes and returns a signed 16-bit integer.

|readInt32E()
|int
|4
|signed, big
|Reads 4 bytes and returns a signed 32-bit integer.

|readInt64E()
|int
|8
|signed, big
|Reads 8 bytes and returns a signed 64-bit integer.

|readSingleE()
|float
|4
|big
|Reads 4 bytes and returns a 32-bit floating-point number.

|readUInt16E()
|int
|2
|unsigned, big
|Reads 2 bytes and returns an unsigned 16-bit integer.

|readUInt32E()
|int
|4
|unsigned, big
|Reads 4 bytes and returns an unsigned 32-bit integer.

|readUInt64E()
|int
|8
|unsigned, big
|Reads 8 bytes and returns an unsigned 64-bit integer.

|readDecimalE()
|Decimal
|8
|big
|Reads a fixed-format 128-bit decimal and returns a precise decimal numeric value.

5+| *primatives : endianX*

|readDoubleX(endian: bool)
|float
|8
|:endian
|Reads 8 bytes and returns a 64-bit floating-point number.

|readInt16X(endian: bool)
|int
|2
|signed, :endian
|Reads 2 bytes and returns a signed 16-bit integer.

|readInt32X(endian: bool)
|int
|4
|signed, :endian
|Reads 4 bytes and returns a signed 32-bit integer.

|readInt64X(endian: bool)
|int
|8
|signed, :endian
|Reads 8 bytes and returns a signed 64-bit integer.

|readSingleX(endian: bool)
|float
|4
|signed, :endian
|Reads 4 bytes and returns a 32-bit floating-point number.

|readUInt16X(endian: bool)
|int
|2
|unsigned, :endian
|Reads 2 bytes and returns an unsigned 16-bit integer.

|readUInt32X(endian: bool)
|int
|4
|unsigned, :endian
|Reads 4 bytes and returns an unsigned 32-bit integer.

|readUInt64X(endian: bool)
|int
|8
|unsigned, :endian
|Reads 8 bytes and returns an unsigned 64-bit integer.

|readDecimalX(endian: bool)
|Decimal
|8
|:endian
|Reads a fixed-format 128-bit decimal and returns a precise decimal numeric value.

5+| *primatives : specialized*

|readIntV7()
|int
|variable
|little
|xxx

|readIntV7X(endian: bool)
|int
|variable
|:endian
|xxx

|readIntV8()
|int
|variable
|little
|xxx

|readIntV8X(endian: bool)
|int
|variable
|little
|xxx

|readBool32(self)
|bool
|4
|little
|xxx

|readGuid(self)
|bytes
|16
|-
|xxx
|===

Strings Methods::
The following methods provide structured access to character and string values, supporting fixed-width, variable-width, and length-prefixed encodings.

[cols="3,1,1,1,6"]
|===
|Name |Return |Bytes |Options |Description

5+|*General String and Character Reading*

|readChar()
|chr
|variable
|-
|Reads a single character from the stream.

|readChars(count: int)
|list[chr]
|:count
|-
|Reads the specified number of characters and returns them as a sequence.

|readString()
|str
|-
|-
|Reads a string from the stream using the default encoding.

|readLine()
|str
|-
|-
|Reads characters until a newline sequence is encountered and returns the resulting text.

5+|*OEM-Encoded (Legacy Codepage) Strings*

|readL16OString(codepage: int = 1252)
|str
|variable
|-
|Reads a 16-bit length-prefixed string using the specified OEM codepage (default 1252).

5+|*Wide (Unicode-style) Strings — Fixed and Variable Length*

|readFWString(length: int)
|str
|length
|-
|Reads a fixed-width wide string of the specified character length.

|readVWString(length: int = 65535, stopValue: int = b'\x00', ms: BytesIO = None)
|str
|variable
|-
|Reads a variable-width wide string, stopping at a terminator or maximum length, optionally writing to a buffer.

|readL8WString(maxLength: int = 0, endian: bool = False)
|str
|1+variable
|:endian
|Reads an 8-bit length-prefixed wide string.

|readL16WString(maxLength: int = 0, endian: bool = False)
|str
|2+variable
|:endian
|Reads a 16-bit length-prefixed wide string.

|readL32WString(maxLength: int = 0, endian: bool = False)
|str
|4+variable
|:endian
|Reads a 32-bit length-prefixed wide string.

// |readLV8WString(maxLength: int = 0, endian: bool = False)
// |str
// |-
// |-
// |xxx

5+|*UTF-Style Unicode Strings (U-Series)*

|readFUString(length: int)
|str
|length
|-
|Reads a fixed-length UTF-encoded string.

|readVUString(length: int = 65535, stopValue: int = b'\x00', ms: BytesIO = None)
|str
|variable
|-
|Reads a variable-length UTF-encoded string, stopping when terminator or length limit is reached.

|readL8UString(maxLength: int = 0, endian: bool = False)
|str
|1+variable
|:endian
|Reads an 8-bit length-prefixed UTF-encoded string.

|readL16UString(maxLength: int = 0, endian: bool = False)
|str
|2+variable
|:endian
|Reads a 16-bit length-prefixed UTF-encoded string.

|readL32UString(maxLength: int = 0, endian: bool = False)
|str
|4+variable
|:endian
|Reads a 32-bit length-prefixed UTF-encoded string.

// |readLV8UString(maxLength: int = 0, endian: bool = False)
// |str
// |-
// |-
// |xxx

5+|*ASCII Strings (A-Series)*

|readFAString(length: int)
|str
|length
|-
|Reads a fixed-length ASCII string.

|readVAString(length: int = 65535, stopValue: int = b'\x00', ms: BytesIO = None)
|str
|-
|-
|Reads a variable-length ASCII string, stopping on terminator or when maximum length is reached.

|readL8AString(maxLength: int = 0, endian: bool = False)
|str
|1+variable
|:endian
|Reads an 8-bit length-prefixed ASCII string.

|readL16AString(maxLength: int = 0, endian: bool = False)
|str
|2+variable
|:endian
|Reads a 16-bit length-prefixed ASCII string.

|readL32AString(maxLength: int = 0, endian: bool = False)
|str
|4+variable
|:endian
|Reads a 32-bit length-prefixed ASCII string.

// |readLV8AString(maxLength: int = 0, endian: bool = False)
// |str
// |-
// |-
// |xxx

5+|*Extended-Encoding Strings (X-Series)*

|readFXString(encoding: str, length: int)
|str
|length^
|-
|Reads a fixed-length string using a specified encoding.

|readVXString(encoding: str, length: int = 65535, stopValue: int = b'\x00', ms: BytesIO = None)
|str
|variable
|-
|Reads a variable-length string using the 

|readL8XString(encoding: str, maxLength: int = 0, endian: bool = False)
|str
|1+variable
|:endian
|Reads an 8-bit length-prefixed string with custom encoding.specified encoding

|readL16XString(encoding: str, maxLength: int = 0, endian: bool = False)
|str
|2+variable
|:endian
|Reads a 16-bit length-prefixed string with custom encoding.

|readL32XString(encoding: str, maxLength: int = 0, endian: bool = False)
|str
|4+variable
|:endian
|Reads a 16-bit length-prefixed string with custom encoding.

// |readLV8XString(encoding: str, maxLength: int = 0, endian: bool = False)
// |str
// |-
// |-
// |xxx
|===

Struct Methods::
Struct operations allow reading structured records from a stream using a defined format.
Records may be interpreted using one of three modes:
Factory (F)::: A callable is executed to construct the object directly.
Pattern (P)::: A class and pattern string define the structure layout.
Struct (S)::: A class is instantiated using a fixed byte size for interpretation.

[cols="3,1,1,1,6"]
|===
|Name |Return |Bytes |Options |Description

5+| *struct : single*

|readF(factory: callable)
|object
|cls
|-
|Uses a factory function to construct and return a record from the current stream position.

|readP(cls: callable, pat: str)
|object
|cls
|-
|Reads structured data according to the provided pattern string and instantiates an object using the specified class.

|readS(cls: object, sizeOf: int = -1)
|object
|cls
|-
|Reads a fixed-size region of bytes and instantiates the specified class with the resulting byte block.
|===

Structs Arrays::
Struct array operations allow reading multiple structured records from a stream in sequence.
Arrays may be retrieved using:
Factory-based construction (F-Series)::: Uses a callable factory for each element
Pattern-based parsing (P-Series)::: Uses a class and pattern definition for each element
Fixed-size struct parsing (S-Series)::: Uses a class and byte size for each element
Length-prefixed methods (`L8`, `L16`, `L32`) read a prefixed count before processing,
while variable-length (`LV7`, `LV8`) read until a stop-condition is reached.

[cols="3,1,1,1,6"]
|===
|Name |Return |Bytes |Options |Description

5+|*Factory-Based Arrays (F-Series)*

|readFArray(factory: callable, count: int, obj: list[object] = None)
|list[object]
|cls
|-
|Reads a fixed number of records using a factory function.

|readFIArray(factory: callable, count: int, obj: list[object] = None)
|list[object]
|cls
|-
|Reads a fixed number of factory-produced items, storing them into an indexable array.

|readL8FArray(factory: callable, endian: bool = False, obj: list[object] = None)
|list[object]
|cls
|-
|Reads an 8-bit length-prefixed array of factory-produced objects.

|readL16FArray(factory: callable, endian: bool = False, obj: list[object] = None)
|list[object]
|cls
|-
|Reads a 16-bit length-prefixed array of factory-produced objects.

|readL32FArray(factory: callable, endian: bool = False, obj: list[object] = None)
|list[object]
|cls
|-
|Reads a 32-bit length-prefixed array of factory-produced objects.

|readLV7FArray(factory: callable, endian: bool = False, obj: list[object] = None)
|list[object]
|cls
|-
|Reads a variable-length array (7-bit encoded count) using a factory.

|readLV8FArray(factory: callable, endian: bool = False, obj: list[object] = None)
|list[object]
|cls
|-
|Reads a variable-length array (8-bit encoded count) using a factory.

5+|*Pattern-Based Arrays (P-Series)*

|readL8PArray(cls: callable, pat: str, obj: list[object] = None)
|list[object]
|cls
|-
|Reads an 8-bit length-prefixed array using a class and pattern.

|readL16PArray(cls: callable, pat: str, endian: bool = False, obj: list[object] = None)
|list[object]
|cls
|-
|Reads a 16-bit length-prefixed array using a pattern specification.

|readL32PArray(cls: callable, pat: str, endian: bool = False, obj: list[object] = None)
|list[object]
|cls
|-
|Reads a 32-bit length-prefixed array using a pattern specification.

|readLV7PArray(cls: callable, pat: str, endian: bool = False, obj: list[object] = None)
|list[object]
|cls
|-
|Reads a variable-length array (7-bit encoded) using a pattern specification.

|readLV8PArray(cls: callable, pat: str, endian: bool = False, obj: list[object] = None)
|list[object]
|cls
|-
|Reads a variable-length array (8-bit encoded) using a pattern specification.

|readPArray(cls: callable, pat: str, count: int, obj: list[object] = None)
|list[object]
|cls
|-
|Reads a fixed-length pattern-based structured array.

5+|*Struct-Based Arrays (S-Series)*

|readL8SArray(cls: object, sizeOf: int = 0, obj: list[object] = None)
|list[object]
|cls
|-
|Reads an 8-bit length-prefixed array of objects using byte-size interpretation.

|readL16SArray(cls: object, sizeOf: int = 0, endian: bool = False, obj: list[object] = None)
|list[object]
|cls
|-
|Reads a 16-bit length-prefixed array of fixed-size structs.

|readL32SArray(cls: object, sizeOf: int = 0, endian: bool = False, obj: list[object] = None)
|list[object]
|cls
|-
|Reads a 32-bit length-prefixed array of fixed-size structs.

|readLV7SArray(cls: object, sizeOf: int = 0, endian: bool = False, obj: list[object] = None)
|list[object]
|cls
|-
|Reads a variable-length array (7-bit encoded) of fixed-size structs.

|readLV8SArray(cls: object, sizeOf: int = 0, endian: bool = False, obj: list[object] = None)
|list[object]
|cls
|-
|Reads a variable-length array (8-bit encoded) of fixed-size structs.

|readSArray(cls: object, count: int, sizeOf: int = 0, obj: list[object] = None)
|list[object]
|cls
|-
|Reads a fixed number of struct records using a known byte size.
|===

Struct Each::
"Each" operations iterate through structured data sequentially, returning one record at a time rather than as a full array.
These methods are useful for streaming scenarios, large datasets, or when processing records without storing them in memory.

[cols="3,1,1,1,6"]
|===
|Name |Return |Bytes |Options |Description

|readSEach(cls: object, count: int)
|list[object]
|cls
|-
|Iterates through a fixed number of struct records, yielding each object instance one at a time.

|readTEach(cls: object, sizeOf: int, count: int)
|list[object]
|cls
|-
|Iterates through a fixed-size block of struct data, reading each element using the specified byte size per record.
|===

Structs Lists::
Struct List methods function similarly to Struct Arrays, but return *list-based collection types* instead of raw arrays.
Lists allow appending, mutability, and higher-level operations when working with structured record collections.
As before, the methods fall into three categories:
Factory-Based (F-Series)::: Uses a callable factory for item construction
Pattern-Based (P-Series)::: Uses a class and pattern string to parse items
Struct-Based (S-Series)::: Uses a class and byte size to interpret items
Length-prefixed `L8` / `L16` / `L32` methods read the count from the stream before parsing,
while `LV7` / `LV8` read a variable-length encoded count.

[cols="3,1,1,1,6"]
|===
|Name |Return |Bytes |Options |Description

5+|*Factory-Based Lists (F-Series)*
|readL8FList(actory: callable, obj: object = None)
|list[object]
|cls
|-
|Reads an 8-bit length-prefixed list using a factory.

|readL16FList(factory: callable, endian: bool = False, obj: object = None)
|list[object]
|cls
|-
|Reads a 16-bit length-prefixed list using a factory.

|readL32FList(factory: callable, endian: bool = False, obj: object = None)
|list[object]
|cls
|-
|Reads a 32-bit length-prefixed list using a factory.

|readLV7FList(factory: callable, endian: bool = False, obj: object = None)
|list[object]
|cls
|-
|Reads a variable-length list (7-bit encoded count) using a factory.

|readLV8FList(factory: callable, endian: bool = False, obj: object = None)
|list[object]
|cls
|-
|Reads a variable-length list (8-bit encoded count) using a factory.

|readFList(factory: callable, count: int, obj: object = None)
|list[object]
|cls
|-
|Reads a fixed number of list items using a factory.

|readFIList(factory: callable, count: int, obj: object = None)
|list[object]
|cls
|-
|Reads a fixed number of factory-generated list elements while preserving their insertion order.

5+|*Pattern-Based Lists (P-Series)*

|readL8PList(cls: callable, pat: str, obj: list[object] = None)
|list[object]
|cls
|-
|Reads an 8-bit length-prefixed pattern-defined record list.

|readL16PList(cls: callable, pat: str, endian: bool = False, obj: list[object] = None)
|list[object]
|cls
|-
|Reads a 16-bit length-prefixed pattern-based list.

|readL32PList(cls: callable, pat: str, endian: bool = False, obj: list[object] = None)
|list[object]
|cls
|-
|Reads a 32-bit length-prefixed pattern-based list.

|readLV7PList(cls: callable, pat: str, endian: bool = False, obj: list[object] = None)
|list[object]
|cls
|-
|Reads a variable-length (7-bit encoded) pattern-defined list.

|readLV8PList(cls: callable, pat: str, endian: bool = False, obj: list[object] = None)
|list[object]
|cls
|-
|Reads a variable-length (8-bit encoded) pattern-defined list.

|readPList(cls: callable, pat: str, count: int, obj: list[object] = None) 
|list[object]
|cls
|-
|Reads a fixed number of patterned items into a list.

5+|*Struct-Based Lists (S-Series)*

|readL8SList(cls: object, sizeOf: int = 0, obj: list[object] = None)
|list[object]
|cls
|-
|Reads an 8-bit length-prefixed list of fixed-size struct records.

|readL16SList(cls: object, sizeOf: int = 0, endian: bool = False, obj: list[object] = None)
|list[object]
|cls
|-
|Reads a 16-bit length-prefixed list of struct records.

|readL32SList(cls: object, sizeOf: int = 0, endian: bool = False, obj: list[object] = None)
|list[object]
|cls
|-
|Reads a 32-bit length-prefixed list of struct records.

|readLV7SList(cls: object, sizeOf: int = 0, endian: bool = False, obj: list[object] = None)
|list[object]
|cls
|-
|Reads a variable-length (7-bit encoded) list of fixed-size struct records.

|readLV8SList(cls: object, sizeOf: int = 0, endian: bool = False, obj: list[object] = None)
|list[object]
|cls
|-
|Reads a variable-length (8-bit encoded) list of fixed-size struct records.

|readSList(cls: object, count: int, sizeOf: int = 0, obj: list[object] = None)
|list[object]
|cls
|-
|Reads a fixed number of struct records and places them into a list.
|===

Structs Many::
"Many" operations read *key-value structured data* from a stream, producing a *mapping/dictionary* rather than arrays or lists.
These methods support three construction modes:
Factory-Based (F-Series)::: Keys and values are created using callable factories
Pattern-Based (P-Series)::: Keys are parsed using a class and pattern string, values by factory
Struct-Based (S-Series)::: Keys and/or values are parsed using fixed-size structures
Additionally, `L8` / `L16` / `L32` methods read counts using length-prefixes,
while `LV7` / `LV8` read a variable-length encoded count.

[cols="3,1,1,1,6"]
|===
|Name |Return |Bytes |Options |Description

5+|*Factory-Based Many (F-Series)*

|readL8FMany(clsKey: object, keyFactory: callable, valueFactory: callable, endian: bool = False, obj: object = None)
|dict[object, object]
|-
|-
|Reads an 8-bit length-prefixed key-value map using factories for keys and values.

|readL16FMany(clsKey: object, keyFactory: callable, valueFactory: callable, endian: bool = False, obj: object = None)
|dict[object, object]
|-
|-
|Reads a 16-bit length-prefixed factory-based mapping.

|readL32FMany(clsKey: object, keyFactory: callable, valueFactory: callable, endian: bool = False, obj: object = None)
|dict[object, object]
|-
|-
|Reads a 32-bit length-prefixed key-value mapping.

|readC32FMany(clsKey: object, keyFactory: callable, valueFactory: callable, endian: bool = False, obj: object = None)
|dict[object, object]
|-
|-
|Reads a compressed-32 encoded key-value mapping using factories.

|readFMany(clsKey: object, keyFactory: callable, valueFactory: callable, count: int, obj: object = None)
|dict[object, object]
|-
|-
|Reads a fixed number of key-value entries using factories.

5+|*Pattern-Based Many (P-Series)*

|readL8PMany(clsKey: object, pat: str, valueFactory: callable, endian: bool = False, obj: dict[object, object] = None)
|dict[object, object]
|-
|-
|Reads an 8-bit length-prefixed structured map using pattern-parsed keys and factory-generated values.

|readL16PMany(clsKey: object, pat: str, valueFactory: callable, endian: bool = False, obj: dict[object, object] = None)
|dict[object, object]
|-
|-
|Reads a 16-bit length-prefixed mapping using pattern parsing.

|readL32PMany(clsKey: object, pat: str, valueFactory: callable, endian: bool = False, obj: dict[object, object] = None)
|dict[object, object]
|-
|-
|Reads a 32-bit length-prefixed structured map.

|readLV8PMany(clsKey: object, pat: str, valueFactory: callable, endian: bool = False, obj: dict[object, object] = None)
|dict[object, object]
|-
|-
|Reads a compressed-32 encoded mapping of pattern-defined keys and factory values.

|readPMany(clsKey: object, pat: str, valueFactory: callable, count: int, obj: dict[object, object] = None)
|dict[object, object]
|-
|-
|Reads a fixed number of patterned key-value records.

5+|*Struct-Based Many (S-Series)*

|readL8SMany(clsKey: object, valueFactory: callable, endian: bool = False, obj: dict[object, object] = None)
|dict[object, object]
|-
|-
|Reads an 8-bit length-prefixed key-value mapping using fixed-size struct-based keys.

|readL16SMany(clsKey: object, valueFactory: callable, endian: bool = False, obj: dict[object, object] = None)
|dict[object, object]
|-
|-
|Reads a 16-bit length-prefixed struct-key mapping.

|readL32SMany(clsKey: object, valueFactory: callable, endian: bool = False, obj: dict[object, object] = None)
|dict[object, object]
|-
|-
|Reads a 32-bit length-prefixed struct-key mapping.

|readC32SMany(clsKey: object, valueFactory: callable, endian: bool = False, obj: dict[object, object] = None)
|dict[object, object]
|-
|-
|Reads a compressed-32 encoded struct-based key-value mapping.

|readSMany(clsKey: object, valueFactory: callable, count: int, obj: dict[object, object] = None)
|dict[object, object]
|-
|-
|Reads a fixed number of entries where keys are interpreted as fixed-size structs
|===

Numeric Methods::
Numeric-reading methods extract multi-value numeric data structures such as vectors, matrices, quaternions, and half-precision components from a stream.
These methods are commonly used in geometry processing, model formats, physics, and graphics-related binary data.
[cols="3,1,1,1,6"]
|===
|Name |Return |Bytes |Options |Description

|readHalf()
|float
|2
|-
|Reads a 16-bit IEEE 754 half-precision floating-point value.

|readHalf16()
|float
|2
|-
|Reads a 16-bit integer and treats it as a half-float value.

5+|*Vectors*

|readVector2()
|ndarray
|8
|-
|Reads two 32-bit floats and returns a 2D vector (x, y).

|readHalfVector2()
|ndarray
|4
|-
|Reads two half-precision floats and returns a 2D vector.

|readVector3()
|ndarray
|12
|-
|Reads three 32-bit floats and returns a 3D vector (x, y, z).

|readHalfVector3()
|ndarray
|6
|-
|Reads three 16-bit half-precision floats and returns a 3D vector.

|readHalf16Vector3()
|ndarray
|6
|-
|Reads three 16-bit integers and converts them to a 3D half-precision vector.

|readVector4()
|ndarray
|16
|-
|Reads four 32-bit floats and returns a 4D vector (x, y, z, w).

|readHalfVector4()
|ndarray
|8
|-
|Reads four 16-bit half-precision floats and returns a 4D vector.

5+|*Matrices*

|readMatrix2x2()
|ndarray
|64
|-
|Reads a 2x2 matrix composed of four 32-bit floats.

|readMatrix3x3()
|ndarray
|36
|-
|Reads a 3x3 matrix composed of nine 32-bit floats.

|readMatrix3x4()
|ndarray
|48
|-
|Reads a 3x4 matrix composed of twelve 32-bit floats.

|readMatrix3x3As4x4()
|ndarray
|36
|-
|Reads a 3x3 matrix and expands it internally into a 4x4 matrix structure.

|readMatrix4x4()
|ndarray
|64
|-
|Reads a full 4x4 matrix composed of sixteen 32-bit floats.

5+|*Quaternions*

|readQuaternion()
|quaternion
|16
|-
|Reads a quaternion in XYZ-W order using four 32-bit floats.

|readQuaternionWFirst()
|quaternion
|16
|-
|Reads a quaternion in W-XYZ order (W component first)

|readHalfQuaternion()
|quaternion
|8
|-
|Reads a quaternion where components are stored using half-precision floats.
|===
